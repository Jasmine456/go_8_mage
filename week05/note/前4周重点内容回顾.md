复习



\- 会写代码注释

```GO
单行注释 //
多行注释 /* */

注释的特殊用法
go doc
// TODO 将来需要优化
// NOTE 引人注意
// Deprecated 变量或函数强烈建议不要再使用
...

```



\- fmt.Printf()格式化

```GO
%s string
%d int
%t bool
%T type类型
%p 指针地址
%v 详情
%V 更详细
%f.2 浮点数

```



\- & && | || ^作为单目和双目运算符的区别

```GO
& 1. 当个符号，表示取地址符号  2. 参与运算的两数 各相应的二进位相与（两位均为1 才为1）
&& 逻辑表达式。 and 并且的意思，两个条件表达式
| 参与运算的两数各相应的二进位相或(两位有一个为1就为1)
|| 逻辑或，两边表达式 有一个成立，即为真（true
^ 异或 ，位运算符号。 参与运算的两数各对应的二进位相异或，当两对应的二进位相同时为0，不同时为1.作为一元运算符是表示按位取反，符号位也跟着变


```





\- string与[]byte和[]rune的互转，len(str)是怎么算的，for range str取得到的是什么  

```GO
在go语言中string会显式的转换为[]byte
[]rune 需要强制转换

string中每个元素叫字符，字符有两种
	byte：1个字节，代表ASCII码的一个字符
	rune：4个字节，代表一个UTF-8字符，一个汉字可用一个rune表示
sring底层是byte数组，string的长度就是该byte数组的长度，UTF-8编码下一个汉字占3个byte，即一个汉字占3个长度
string可以转换为[]byte或[]rune类型
string是常量，不能修改其中的字符

s1:="My name is 焦明"
	//s1:="  My"
	arr := []byte(s1)
	brr := []rune(s1)
	fmt.Printf("last byte %d\n",arr[len(arr)-1])//string可以转换为[]byte或[]rune类型
	fmt.Printf("last byte %c\n",arr[len(arr)-1])//byte或rune可以转为string
	fmt.Printf("last rune %d\n",brr[len(brr)-1])
	fmt.Printf("last rune %c\n",brr[len(brr)-1])

	L:=len(s1)
	fmt.Printf("string len %d byte array len %d rune array len %d\n",L,len(arr),len(brr))
	for _,ele:=range s1{
		fmt.Printf("%c",ele)//string中的每個元素是字符
	}
	fmt.Println()
	for i:=0;i<L;i++{
		fmt.Printf("%d",s1[i])//【i】前面应该出现数组或切片，这里自动把string转成了【】byte 而不是[]rune
	}

```



\- type ms map[string]string和type ms=map[string]string的区别是什么

```GO
type ms map[string]string //自定义类型，一个map，key和value都是字符串类型
type ms=map[string]string //类型别名
```



\- 初始化数组arr:=[5]int{};arr:=[...]{1,2,3}

```GO
arr:=[5]int{}
arr:=[...]{1,2,3}//...表示根据{}里元素的个数推断出数组的长度
```





\- 初始化切片arr:=[]int{1,2,3};arr:=make([]int,0,10)

```GO
arr:=[]int{1,2,3}//cap=len=3
arr:=make([]int,0,10)//len=0,cap=10
```



\- 遍历数组/切片的2种方式，有什么有注意的地方

```GO
1.range 
2. for i<len(s,arr)

如果想要修改数组或者切片里的值，再传参数是尽量传入指针，避免内存拷贝

package main

import "fmt"

func update_array(arr [5]int){
	fmt.Printf("array in function,address is %p\n",&arr[0])
	arr[0]=888
}

func update_array2(arr *[5]int){
	fmt.Printf("array in function,address is %p\n",&((*arr)[0]))
	fmt.Printf("array in function,address is %p\n",&arr[0])
	arr[0]=888
}

func update_slice(sli []int){
	fmt.Printf("slice in function,address is %p\n",&sli[0])
	sli[0]=999
}

func update_slice2(sli *[]int){
	fmt.Printf("slice in function,address is %p\n",&(*sli)[0])
	(*sli)[0]=999
}

```



\- slice struct里有哪3个成员，一个切片占多少内存

```GO
slice struct 包含 type slice {arr,len,cap}

一个切片占用24个字节
```





\- 截取子切片、apped返回新切片，都会导致内存共享，扩容后才会分离

```GO


```



\- 函数参数用数组、切片、数组指针、切片指针、指针数组、指针切片的区别

\- map的初始化、添加KV（时间复杂度）、更新KV、删除KV、遍历（随机）

\- 结构体的初始化，如何创建结构体指针，结构体切片的初始化

\- 成员方法用值和用指针的2点区别

\- =赋值、函数的入参、函数的出参 都要发生拷贝，比如arr[0]=user;arr[0].age=18不影响user.age，如果想影响怎么办？

\- switch和case后面可以跟常量、变量或函数表达式，只要它们表示的数据类型相同就行。switch后面可以放空。switch value := num.(type)和switch num.(type)

\- if 后面有2部分，for后面有3部分，各部分的功能

\- 不定长参数如何使用，如何传参，切掉转不定长参数

\- 函数也是一种类型 type f func(string,string) (int,error)

\- defer链的执行顺序，defer后面变量的计算时机

\- panic会顺序执行哪几步，recover在哪一步进行拦截，recover后从哪儿继续执行

\- 如果定义接口。面向接口编程和函数类型的参数有异曲同工之妙

\- 空接口类型var a interface{}，类型断言